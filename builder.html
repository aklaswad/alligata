<script src="parser.js"></script>
<script src="http://code.jquery.com/jquery-2.1.3.min.js"></script>
<script src="coffee-script.js"></script>
<script type="text/coffeescript">
lines = []
connections = []
io = {}
ns = {}
branch = {}
tail = 1
debug = 1
p = (s)-> lines.push s
c = (s)-> connections.push s
d = (s)-> lines.push s if debug
offset = (val) ->
  "Wani.createDCOffset(ctx,#{val})"

funcs =
  audioParam: (name, def)->
    console.log 'ap',this, arguments
    throw "audioParam requires name" unless name?.string?
    throw "audioParam requires default value" unless def?.number?
    name = name.string
    def = def.number
    me = ++tail;
    io[name] = me
    p "nodes[#{me}] = io['#{name}'] = Wani.createAudioParam(ctx,#{def});"
    c "nodes[#{me}].connect(nodes[#{this.dest}]);" if this.dest
    return me

prefix = """
var io = (function (ctx) {
  var io = {};
  var nodes = [];

"""

suffix = """


  // done
  return io;
})(ctx);
"""

generate = (expression) ->
  tail = 0
  io = {}
  lines = []
  connections = []
  ns = {}
  branch = {}
  expression = expression.replace /^\s+/,''
  expression = expression.replace /\s+$/,''
  try
    tree = parser.parse(expression)
  catch e
    throw "Parse error: #{e}"
  console.log tree
  # $('#tree').val( JSON.stringify tree )
  # p "nodes[0] = io['output'] = ctx.createGain()"
  try
    _generate tree, {}
  catch e
    throw "Compile error: #{e}"
  prefix + "  " + lines.join("\n  ") + "\n\n  " + connections.join("\n  ") + suffix

_resolve_prop = () -> 1

_generate = (tree, ctx) ->
  if tree.func
    name = tree.func
    throw "Undefined function [#{name}]" unless funcs[name]
    return funcs[name].apply(ctx,tree.args.args)
  if tree.s
    _generate tree.s, {}
    _generate tree.ss, {}
    return
  else if tree.lval
    lval = _generate tree.lval, {lval:1}
    throw "invalid lvalue #{lval}" unless lval?
    if lval.type == 'branch'
      branch[lval.name] = tree.rval
      return
    _generate tree.rval, {dest: lval}
    return
  else if tree.sigil == '$'
    name = tree.prop.join('.')
    if io[name]
      c "nodes['#{io[name]}'].connect(nodes[#{ctx.dest}]);" if ctx.dest
      return io[name]
    me = ++tail
    p "nodes[#{me}] = io['#{name}'] = ctx.createGain(); // make io"
    c "nodes[#{me}].connect(nodes[#{ctx.dest}]);" if ctx.dest
    io[name] = me
    return me
  else if tree.sigil == ':'
    name = tree.prop.join '.'
    if io[name]
      c "nodes[#{io[name]}].connect(nodes[#{ctx.dest}]);" if ctx.dest
      return io[name]
    me = ++tail
    p "nodes[#{me}] = io['#{name}'] = Wani.createAudioParam(ctx); // make io"
    c "nodes[#{me}].connect(nodes[#{ctx.dest}]);" if ctx.dest
    io[name] = me
    return me
  else if tree.sigil == '#'
    name = tree.prop.join '.'
    if ctx.lval
      branch[name];
      return {type: 'branch', name: name}
    else
      brc = branch[name]
      throw "unregistered branch #{name} was invoked" unless brc?
      return _generate brc,ctx
  else if tree.prop
    name = tree.prop.join '.'
    if ns[name]
      c "nodes[#{io[name]}].connect(nodes[#{ctx.dest}]);" if ctx.dest
      return ns[name]
    me = ++tail
    ns[name] = me
    p "nodes[#{me}] = #{name}; // Existing node"
    c "nodes[#{me}].connect(nodes[#{ctx.dest}]);" if ctx.dest
    io[name] = me
    return me
  else if tree.number
    me = ++tail
    p "nodes[#{me}] = #{offset(tree.number)}; // number"
    c "nodes[#{me}].connect(nodes[#{ctx.dest}]);"
    return me
  else if tree.additive
    _generate tree.additive, {dest: ctx.dest, subdest: ctx.subdest}
    return
  else if tree.op == '+'
    if ctx.sub
      _generate tree.l, {add:1, dest:ctx.dest, subdest:ctx.subdest}
      _generate tree.r, {add:1, dest:ctx.subdest, subdest:ctx.dest}
    else
      _generate tree.l, {add:1, dest:ctx.dest, subdest:ctx.subdest}
      _generate tree.r, {add:1, dest:ctx.dest, subdest:ctx.subdest}
    return
  else if tree.op == '-'
    unless ctx.subdest?
      ctx.subdest = ++tail
      p "nodes[#{ctx.subdest}] = ctx.createGain();"
      p "nodes[#{ctx.subdest}].gain.value = -1"
      c "nodes[#{ctx.subdest}].connect(nodes[#{ctx.dest}]); // negativer for minus()"
    if ctx.sub
      _generate tree.l, {sub:1, dest:ctx.dest, subdest:ctx.subdest}
      _generate tree.r, {sub:1, dest:ctx.dest, subdest:ctx.subdest}
    else
      _generate tree.l, {add:1, dest:ctx.dest, subdest:ctx.subdest}
      _generate tree.r, {sub:1, dest:ctx.subdest, subdest:ctx.dest}
    return
  else if tree.op == '*'
    me = ++tail
    multiplier = ++tail
    p "nodes[#{me}] = ctx.createGain();  // multi(#{me})"
    p "nodes[#{multiplier}] = nodes[#{me}].gain;"
    p "nodes[#{multiplier}].value = 0.0;"
    _generate tree.l, {dest: me}
    _generate tree.r, {dest: multiplier}
    if ctx.dest
      c "nodes[#{me}].connect(nodes[#{ctx.dest}]); // to output from multi(#{me})"
    return me
  else if tree.op == '/'
    throw "division is not supported :P"
  else
    throw "unknown operator"

run = ()->
  expression = $('#expression').val()
  expression = expression.replace /\s+$/, ''
  try
    code = generate(expression)
  catch e
    $('#code').val('')
    $('#error').text(e)
    return
  $('#code').val(code)
  $('#error').text('')

guard = 0
$('#expression').on 'keyup', ()->
  return if guard++
  setTimeout( ()->
    run() if guard > 1
    guard = 0
  , 1000)
  guard++
  run()

$( ()-> run() )
</script>

<style>
html,body {
  width: 100%;
  height: 100%;
}

#expression {
  height: 300px;
  font-size: 14px;
  width: 300px;
  border: 1px solid #789;
  margin: 10px;
  padding: 0;
  box-sizing: border-box;
  display: inline-block;
}

#code {
  width: 300px;
  height: 300px;
  margin: 10px;
  padding: 0;
  box-sizing: border-box;
  display: inline-block;
}
</style>


<div>
<textarea id="expression" />
audioParam('speed',5);
audioParam('depth',0.6);

lfo.frequency = :speed;
outlet = inlet;
outlet.gain = lfo * 0.5 * :depth + (1 - :depth )
</textarea>
<textarea id="code"></textarea>
</div>
<div id="error"></div>
<h1>Expression to WebAudio Circuit</h1>
<div>
  <dl>
    <dt>Supported operators</dt>
    <dd><code>+</code> <code>*</code> <code>-</code></dd>
    <dt>Variables</dt>
    <dd>
      <ul>
        <li><code>name.foo</code> Existing Variable (Must be defined before this generator's code runs)
        <li><code>:name</code>  audioParam
      </ul>
    </dd>
    <dt>function</dt>
    <dd>
      audioParam(name,defaultValue)
<pre>
audioParam("depth", 0.4);

// You can reference after that
output = lfo.gain * :depth;
</pre>
      </ul>
    </dd>

  </dl>
</div>
<div>
